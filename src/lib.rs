use num_bigint::BigUint;

/*

@param n: the number that the function will exponentiate
@param exponent: the exponent of the exponential function
@param modulus: the number that the function will be modules by
@return: the result of the exponential function

 n^exponent mod p
*/
pub fn exponential_function(n: &BigUint, exponent: &BigUint, p: &BigUint) -> BigUint {
    // this method can exponentiate large numbers efficiently and apply the modulus operation in the same step
    n.modpow(exponent, p)

}
/*
@param k: the random number that the prover will add to the challenge
@param c: the value generated by the verifier
@param x: the secret number from the prover
@param q: the modulus of the exponential function
@return: the solution to the challenge

 k - (C * X) mod q
*/

pub fn solve_challenge(k: &BigUint, c: &BigUint, x: &BigUint, q: &BigUint) -> BigUint {
    if *k >= c * x {
    /*
    as there's no just mod() method in BigUint, we use modpow with an exponent of 1. &BigUint::from(1u32) is the same as 1 in BigUint. this is equivalent to (k - (c * x)) ^ 1 % q
    */
     (k - (c * x)).modpow(&BigUint::from(1u32), q)
    } else {
       let result = q - (c * x - k).modpow(&BigUint::from(1u32), q);
        result
    }
}

/*
@param v: the public input from the prover
@param s: the solution to the challenge
@param w: the public input from the prover
@param c: the challenge
@param p: the modulus of the exponential function
@return: the result of the verification helper

r = v^s mod p * w ^c mod p

*/

pub fn verification_helper(v: &BigUint, s: &BigUint, w: &BigUint, c: &BigUint, p: &BigUint) -> BigUint{
  (v.modpow(s, p) * w.modpow(c, p)).modpow(&BigUint::from(1u32), p)
}

/*
@param v: the public input from the prover
@param w: the public input from the prover
@param s: the solution to the challenge
@param q: the modulus of the exponential function
@return: true if the solution is valid, false otherwise

conditions
r1 = alpha ^ s mod p * y1 ^c mod p
r2 = beta ^ s mod p * y2 ^c mod p
*/

pub fn verify_solution(r1: &BigUint, r2: &BigUint, alpha: &BigUint, beta: &BigUint, y1: &BigUint, y2: &BigUint, c: &BigUint, s: &BigUint, p: &BigUint) -> bool {
 let condition_r1 = *r1 == verification_helper(alpha, s, y1, c, p);
 let condition_r2 = *r2 == verification_helper(beta, s, y2, c, p);
 condition_r1 && condition_r2
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_example_1(){
        // the public input prover and verifier agree on including modulus:
        let alpha = BigUint::from(4u32);
        let beta = BigUint::from(9u32);
        let p = BigUint::from(23u32);
        let q = BigUint::from(11u32);

        // the secret number x:
        let x = BigUint::from(6u32);
        // the prover chooses a random number k:
        let k = BigUint::from(7u32);

        // the verifier chooses a random number c:
        let c = BigUint::from(4u32);


        let y1 = exponential_function(&alpha, &x, &p);
        let y2 = exponential_function(&beta, &x, &p);

        assert_eq!(y1, BigUint::from(2u32));
        assert_eq!(y2, BigUint::from(3u32));

        let r1 = exponential_function(&alpha, &k, &p);
        let r2 = exponential_function(&beta, &k, &p);
        assert_eq!(r1, BigUint::from(8u32));
        assert_eq!(r2, BigUint::from(4u32));

        let s = solve_challenge(&k, &c, &x, &q);
        assert_eq!(s, BigUint::from(5u32));


        let result = verify_solution(&r1, &r2, &alpha, &beta, &y1, &y2, &c, &s, &p);
        assert!(result);      
    }
}